 The repository interfaces provided by Spring Data JPA, such as `CrudRepository`, are very powerful for managing data without having to write too much code.  However, there is not much use without a way for end users of the API to interact with. 

When a user interacts with your API, they do so by making  REST calls to a `RestController`.  The `RestController` takes request from the user and accordingly sends commands to the data access layer to accomplish the task requested.

The repository must be a dependency of the controller, and you can make the repository bean available to the controller class using dependency injection.

To make a bean available to a class that depends on it, you can simply add it as a field of the class and in the constructor. Spring Boot will automatically wire in the dependency when it discovers the dependency in the Spring context. 

The example below uses a `PlantRepository` and `PlantController` as an example. To make the repository available to the controller as a dependency, all that has to be done is:
- import `PlantRepository` 
- add it as a field in the `PlantController` class
- add the `PlantRepository` to the constructor and assign it to the field appropriately.

``` java
package com.codecademy.plants.controllers;

import com.codecademy.plants.repositories.PlantRepository;

@RestController
public class PlantController {
	private final PlantRepository plantRepository;  

	public PlantController(final PlantRepository plantRepository) {
		this.plantRepository = plantRepository;
	}
}
```

# Making Queries to the Database
## findAll
GET requests should be used to retrieve information out of your database.  So a GET request should trigger repository methods like `findAll()` or  `findById(Integer id)`. 

The controller may include some `@GetMappings`:
``` java
 @GetMapping("/people")  
  public Iterable<Person> getAllPeople() {  
    return this.personRepository.findAll();  
  }  
  
  @GetMapping("/people/{id}")  
  public Optional<Person> getPersonById(@PathVariable("id") Integer id) {  
    return this.personRepository.findById(id);  
  }
```

The `findAll()` method offered by the `CrudRepository` is used to get `Person` entries.
This method returns an `Iterable`, which is just a simplified interface for a collection in Java.

You can contact this using a GET request:
``` bash
curl localhost:4001/people
```

## findById
The method `findById(Integer id)` in the `CrudRepository` can be used to get entries by their id's. 

``` Java
@GetMapping("/people/{id}")  
public Optional<Person> getPersonById(@PathVariable("id") Integer id) {  
  return this.personRepository.findById(id);  
}
```

This method returns an `Optional`. This is because the user may pass an ID that does not exist in the database. This type will therefore return a null if the id supplied is not present in the database.

## save
A POST request is used to create new information in the database. Using the `CrudRepository`'s `.save()` method, new records are created in the database.

The `.save()5` method uses your model as a parameter, and uses all the annotations added to indicate the columns as its basis when it uses the ORM to create underlying SQL `INSERT` statement. 

``` Java
@PostMapping("/people")  
public Person createNewPerson(@RequestBody Person person) {  
  Person newPerson = this.personRepository.save(person);  
  return newPerson;  
}
```

The `.save()` method returns a `Person` as well, and the only difference between this `newPerson` and the original `person` passed by the user is that the `newPerson` will have an `id` field, generated by means of the `@GeneratedValue` annotation from the model definition. So this person is returned so the ID can be recorded.

Therefore, when making a post request, you do not need to pass an ID also:
``` Java
curl -X POST localhost:4001/plants -H "Content-Type: application/json" -d "{\"name\":\"Ficus\",\"quantity\":2, \"wateringFrequency\": 3, \"hasFruit\": false}"
```

## update

The `.save()` method can also be used for updating existing entries. A common flow includes:
- fetching the entry from the database by id
- update some attribute of the entry
- call `.save()` to persist the change

A PUT request is used to update entries in the database.

``` Java
@PutMapping("/people/{id}")  
public Person updatePerson(@PathVariable("id") Integer id, @RequestBody Person p) {  
  Optional<Person> personToUpdateOptional = this.personRepository.findById(id);  
  if (!personToUpdateOptional.isPresent()) {  
    return null;  
  }  
  
  // Since isPresent() was true, we can .get() the Person object out of the Optional  
  Person personToUpdate = personToUpdateOptional.get();  
  
  if (p.getName() != null) {  
    personToUpdate.setName(p.getName());  
  }  
  if (p.getAge() != null) {  
    personToUpdate.setAge(p.getAge());  
  }  
  if (p.getEyeColor() != null) {  
    personToUpdate.setEyeColor(p.getEyeColor());  
  }  
  
  Person updatedPerson = this.personRepository.save(personToUpdate);  
  return updatedPerson;  
}
```

`isPresent()` is used to check if the person was present in the database.  If it was not present, that meant the `id` did NOT exist in the database, so the method terminates early by returning `null` to the response body.

The `Person` object passed in the request body is used to store the new field values that should be used to update the targeted entry. It does not need to have ALL the fields that a `Person` has. When Spring Boot (via Jackson) converts the request body to a `Person` object, it simply sets any fields that are missing to `null`. Because of this, we are able to use a single endpoint to update any field of the `Person`. We can use `if` statements to update a field of the target database entry ONLY IF the corresponding field in the request body object was not null.

## delete
The `CrudRepository` offers a `delete` method that accepts the instance of the model you wish to delete.

``` Java
@DeleteMapping("/people/{id}")  
public Person deletePerson(@PathVariable("id") Integer id) {  
  Optional<Person> personToDeleteOptional = this.personRepository.findById(id);  
  if (!personToDeleteOptional.isPresent()) {  
    return null;  
  }  
  Person personToDelete = personToDeleteOptional.get();  
  this.personRepository.delete(personToDelete);  
  return personToDelete;  
}
```

# Advanced Queries

Adding `required = false` inside  `@RequestParam` annotation, allows us to optionally add more query parameters if a user would like to search by a different field value instead.

We would do this by:

- Extending the repository interface
``` Java
List<Person> findByAgeLessThan(Integer age);
```
- Update search method
``` java
@GetMapping("/people/search")  
public List<Person> searchPeople(  
  @RequestParam(name = "eyeColor", required = false) String eyeColor,  
  @RequestParam(name = "maxAge", required = false) Integer maxAge  
) {  
  if (eyeColor != null) {  
    return this.personRepository.findByEyeColor(eyeColor)  
  } else if (maxAge != null) {  
    return this.personRepository.findByAgeLessThan(maxAge);  
  } else {  
    return new ArrayList<>();  
  }  
}
```

You can get more advanced using `AND` queries so that you can filter by both eye colour and max age:

Interface:
``` java
List<Person> findByEyeColorAndAgeLessThan(String eyeColor, Integer age);
```
Controller:
``` java
@GetMapping("/people/search")  
public List<Person> searchPeople(  
  @RequestParam(name = "eyeColor", required = false) String eyeColor,  
  @RequestParam(name = "maxAge", required = false) Integer maxAge  
) {  
  if (eyeColor != null && maxAge != null) {  
    return this.personRepository.findByEyeColorAndAgeLessThan(eyeColor, maxAge);  
  } else if (eyeColor != null) {  
    return this.personRepository.findByEyeColor(eyeColor);  
  } else if (maxAge != null) {  
    return this.personRepository.findByAgeLessThan(maxAge);  
  } else {  
    return new ArrayList<>();  
  }  
}
```

NOTE: The naming of methods in the repository is incredibly important. The rules are detailed here:  https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html